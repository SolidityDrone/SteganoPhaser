var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// node_modules/tsup/assets/esm_shims.js
import { fileURLToPath } from "url";
import path from "path";
var init_esm_shims = __esm({
  "node_modules/tsup/assets/esm_shims.js"() {
    "use strict";
  }
});

// src/errors.ts
var MissingDataError, NetworkError, AuthenticationError;
var init_errors = __esm({
  "src/errors.ts"() {
    "use strict";
    init_esm_shims();
    MissingDataError = class extends Error {
      constructor(message) {
        super(message);
        this.name = "MissingDataError";
      }
    };
    NetworkError = class extends Error {
      constructor(message) {
        super(message);
        this.name = "NetworkError";
      }
    };
    AuthenticationError = class extends Error {
      constructor(message) {
        super(message);
        this.name = "AuthenticationError";
      }
    };
  }
});

// src/client.ts
var require_client = __commonJS({
  "src/client.ts"(exports, module) {
    "use strict";
    init_esm_shims();
    init_errors();
    var NameStone2 = class {
      baseUrl;
      headers;
      /**
       * Creates a NameStone instance.
       * @param apiKey - NameStone API key for authentication.
       * @param config - Configuration options for NameStone.
       */
      constructor(apiKey, config) {
        if (config?.baseUrl) {
          this.baseUrl = config.baseUrl.replace(/\/$/, "");
        } else if (config?.network === "sepolia") {
          this.baseUrl = "https://namestone.com/api/public_v1_sepolia";
        } else {
          this.baseUrl = "https://namestone.com/api/public_v1";
        }
        this.headers = {
          "Content-Type": "application/json"
        };
        if (apiKey) {
          this.headers["Authorization"] = apiKey;
        }
      }
      async request(endpoint, method, data) {
        const url = `${this.baseUrl}${endpoint}`;
        const config = {
          method,
          headers: this.headers,
          body: data ? JSON.stringify(data) : void 0
        };
        const res = await fetch(url, config);
        if (!res.ok) {
          const errorMessage = await res.text();
          if (res.status === 401) {
            throw new AuthenticationError(`Authentication failed: ${errorMessage}`);
          }
          throw new NetworkError(`HTTP error! status: ${res.status}, message: ${errorMessage}`);
        }
        return res.json();
      }
      async requestText(endpoint) {
        const url = `${this.baseUrl}${endpoint}`;
        const config = {
          method: "GET",
          headers: {
            Accept: "text/plain"
          }
        };
        const res = await fetch(url, config);
        if (!res.ok) {
          const errorMessage = await res.text();
          throw new NetworkError(errorMessage);
        }
        return res.text();
      }
      /**
       * Helper method to check if API key is present for authenticated endpoints
       * @throws {AuthenticationError} If API key is not provided
       */
      checkApiKey() {
        if (!this.headers["Authorization"]) {
          throw new AuthenticationError("API key is required for this endpoint");
        }
      }
      /**
       * Sets a name with associated data.
       * @param params - The parameters for setting a name.
       * @returns A promise that resolves when the name is set.
       * @throws {AuthenticationError} If authentication fails.
       * @throws {NetworkError} If there's a network error.
       */
      async setName(params) {
        this.checkApiKey();
        return await this.request("/set-name", "POST", params);
      }
      /**
       * Claims a name with associated data.
       * @param params - The parameters for claiming a name.
       * @returns A promise that resolves when the name is claimed.
       * @throws {AuthenticationError} If authentication fails.
       * @throws {NetworkError} If there's a network error.
       */
      async claimName(params) {
        this.checkApiKey();
        const single_claim = params.single_claim || 0;
        const queryParams = new URLSearchParams();
        queryParams.append("single_claim", single_claim.toString());
        const endpoint = `/claim-name?${queryParams}`;
        return await this.request(endpoint, "POST", params);
      }
      /**
       * Retrieves names based on specified criteria.
       * @param params - The parameters for retrieving names.
       * @returns A promise that resolves to an array of NameData.
       * @throws {AuthenticationError} If authentication fails.
       * @throws {NetworkError} If there's a network error.
       */
      async getNames(params) {
        this.checkApiKey();
        const queryParams = new URLSearchParams();
        for (const [key, value] of Object.entries(params)) {
          if (value !== void 0) {
            queryParams.append(key, value.toString());
          }
        }
        const endpoint = `/get-names?${queryParams.toString()}`;
        return this.request(endpoint, "GET");
      }
      /**
       * Searches for names based on specified criteria.
       * @param params - The parameters for searching names.
       * @returns A promise that resolves to an array of NameData.
       * @throws {AuthenticationError} If authentication fails.
       * @throws {NetworkError} If there's a network error.
       */
      async searchNames(params) {
        this.checkApiKey();
        const queryParams = new URLSearchParams();
        for (const [key, value] of Object.entries(params)) {
          if (value !== void 0) {
            queryParams.append(key, value.toString());
          }
        }
        const endpoint = `/search-names?${queryParams.toString()}`;
        return this.request(endpoint, "GET");
      }
      /**
       * Deletes a name from the specified domain.
       * @param params - The parameters for deleting a name.
       * @returns A promise that resolves when the name is deleted.
       * @throws {AuthenticationError} If authentication fails.
       * @throws {NetworkError} If there's a network error.
       */
      async deleteName(params) {
        this.checkApiKey();
        return await this.request("/delete-name", "POST", params);
      }
      /**
       * Sets domain data.
       * @param params - The parameters for setting a domain.
       * @returns A promise that resolves when the domain is set.
       * @throws {AuthenticationError} If authentication fails.
       * @throws {NetworkError} If there's a network error.
       */
      async setDomain(params) {
        this.checkApiKey();
        return await this.request("/set-domain", "POST", params);
      }
      /**
       * Retrieves domain data.
       * @param domain - Optional domain to retrieve data for.
       * @returns A promise that resolves to an array of DomainData.
       * @throws {AuthenticationError} If authentication fails.
       * @throws {NetworkError} If there's a network error.
       */
      async getDomain(params) {
        this.checkApiKey();
        const queryParams = new URLSearchParams();
        for (const [key, value] of Object.entries(params)) {
          if (value !== void 0) {
            queryParams.append(key, value.toString());
          }
        }
        const endpoint = `/get-domain?${queryParams.toString()}`;
        return this.request(endpoint, "GET");
      }
      async getSiweMessage(params) {
        const queryParams = new URLSearchParams();
        for (const [key, value] of Object.entries(params)) {
          if (value !== void 0) {
            queryParams.append(key, value.toString());
          }
        }
        const endpoint = `/get-siwe-message?${queryParams.toString()}`;
        return this.requestText(endpoint);
      }
      /**
       * Enables a new domain for NameStone and returns an API key.
       * Note: Domain resolver must be NameStone's resolver: 0xA87361C4E58B619c390f469B9E6F27d759715125
       * @param params - The parameters for enabling a domain.
       * @returns A promise that resolves to the API key response.
       * @throws {AuthenticationError} If authentication fails.
       * @throws {NetworkError} If there's a network error.
       */
      async enableDomain(params) {
        return this.request("/enable-domain", "POST", params);
      }
    };
    module.exports = NameStone2;
  }
});

// src/index.ts
init_esm_shims();
var import_client = __toESM(require_client(), 1);
init_errors();
var src_default = import_client.default;
export {
  AuthenticationError,
  MissingDataError,
  NetworkError,
  src_default as default
};
